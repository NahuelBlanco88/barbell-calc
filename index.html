<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Barbell">
<meta name="theme-color" content="#0a0a0f">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<title>Barbell Calculator</title>
<style>
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --bg: #0a0a0f;
  --surface: #16161e;
  --surface2: #1e1e2a;
  --border: #2a2a3a;
  --text: #e8e8f0;
  --text-dim: #8888a0;
  --accent: #6c7aff;
  --accent-glow: rgba(108, 122, 255, 0.15);

  --plate-red: #d42b2b;
  --plate-blue: #2b5fd4;
  --plate-yellow: #d4c12b;
  --plate-green: #2bb84d;
  --plate-white: #e8e8e8;

  --safe-top: env(safe-area-inset-top, 0px);
  --safe-bottom: env(safe-area-inset-bottom, 0px);
}

html, body {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', system-ui, sans-serif;
  -webkit-font-smoothing: antialiased;
  overflow-x: hidden;
}

body {
  padding-top: var(--safe-top);
  padding-bottom: var(--safe-bottom);
  display: flex;
  flex-direction: column;
  min-height: 0;
}

/* === TOTAL WEIGHT DISPLAY === */
.total-section {
  text-align: center;
  padding: 24px 16px 8px;
  flex-shrink: 0;
  position: relative;
}

.total-weight {
  font-size: 72px;
  font-weight: 800;
  letter-spacing: -3px;
  line-height: 1;
  font-variant-numeric: tabular-nums;
  background: linear-gradient(180deg, #ffffff 0%, #b0b0d0 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.total-unit {
  font-size: 24px;
  font-weight: 600;
  letter-spacing: -1px;
  color: var(--text-dim);
  margin-left: 2px;
}

.total-label {
  font-size: 13px;
  color: var(--text-dim);
  margin-top: 4px;
  letter-spacing: 0.5px;
  text-transform: uppercase;
}

/* Gear button */
.gear-btn {
  position: absolute;
  top: 20px;
  right: 12px;
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 50%;
  background: var(--surface2);
  color: var(--text-dim);
  font-size: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.15s;
}

.gear-btn:active {
  transform: scale(0.9);
  background: var(--border);
}

.gear-btn svg {
  width: 20px;
  height: 20px;
  fill: currentColor;
}

.gear-btn.has-limits {
  color: var(--accent);
}

/* === BAR SELECTOR === */
.bar-selector {
  display: flex;
  gap: 8px;
  justify-content: center;
  padding: 12px 16px;
  flex-shrink: 0;
}

.bar-btn {
  flex: 1;
  max-width: 160px;
  padding: 10px 16px;
  border: 2px solid var(--border);
  border-radius: 12px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  -webkit-tap-highlight-color: transparent;
}

.bar-btn.active {
  border-color: var(--accent);
  background: var(--accent-glow);
  color: var(--text);
  box-shadow: 0 0 20px rgba(108, 122, 255, 0.1);
}

.bar-btn span {
  display: block;
  font-size: 11px;
  color: var(--text-dim);
  margin-top: 2px;
  font-weight: 400;
}

/* === TARGET WEIGHT CALCULATOR === */
.target-section {
  padding: 0 16px 8px;
  flex-shrink: 0;
}

.target-row {
  display: flex;
  gap: 8px;
}

.target-input {
  flex: 1;
  padding: 10px 14px;
  border: 2px solid var(--border);
  border-radius: 12px;
  background: var(--surface);
  color: var(--text);
  font-size: 16px;
  font-weight: 600;
  outline: none;
  -webkit-appearance: none;
  font-family: inherit;
}

.target-input::placeholder {
  color: var(--text-dim);
  font-weight: 400;
}

.target-input:focus {
  border-color: var(--accent);
}

.target-btn {
  padding: 10px 20px;
  border: 2px solid var(--accent);
  border-radius: 12px;
  background: var(--accent-glow);
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.15s;
  white-space: nowrap;
}

.target-btn:active {
  transform: scale(0.96);
}

.target-message {
  text-align: center;
  font-size: 13px;
  font-weight: 500;
  margin-top: 6px;
  min-height: 18px;
  transition: opacity 0.2s;
}

.target-message.exact {
  color: #2bb84d;
}

.target-message.closest {
  color: #d4c12b;
}

.target-message.error {
  color: #ff6b6b;
}

/* === BARBELL VISUAL === */
.barbell-container {
  padding: 16px 8px;
  overflow-x: auto;
  overflow-y: hidden;
  flex-shrink: 0;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
}

.barbell-container::-webkit-scrollbar {
  display: none;
}

.barbell-svg {
  display: block;
  margin: 0 auto;
  max-width: 100%;
  height: auto;
}

/* === PER-SIDE BREAKDOWN === */
.breakdown {
  padding: 4px 16px 8px;
  text-align: center;
  flex-shrink: 0;
}

.breakdown-title {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--text-dim);
  margin-bottom: 6px;
}

.breakdown-hint {
  font-size: 10px;
  color: var(--text-dim);
  opacity: 0.6;
  margin-bottom: 6px;
}

.breakdown-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: center;
}

.breakdown-chip {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  border-radius: 8px;
  background: var(--surface2);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.15s;
  border: 1.5px solid transparent;
}

.breakdown-chip:active {
  transform: scale(0.92);
  border-color: #ff6b6b88;
  background: #ff6b6b18;
}

.breakdown-chip .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  flex-shrink: 0;
}

.breakdown-chip .count {
  color: var(--text-dim);
  font-size: 11px;
}

.breakdown-empty {
  font-size: 13px;
  color: var(--text-dim);
  font-style: italic;
}

/* === PLATE BUTTONS === */
.plates-section {
  padding: 8px 12px 0;
}

.plates-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
}

.plate-btn {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 12px 4px 8px;
  border: 2px solid var(--border);
  border-radius: 14px;
  background: var(--surface);
  color: var(--text);
  font-size: 16px;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.15s;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  min-height: 60px;
}

.plate-btn:active:not(.at-limit) {
  transform: scale(0.94);
}

.plate-btn .plate-label {
  font-size: 10px;
  color: var(--text-dim);
  margin-top: 2px;
  font-weight: 400;
}

.plate-btn .plate-count {
  position: absolute;
  top: -6px;
  right: -6px;
  min-width: 20px;
  height: 20px;
  padding: 0 5px;
  border-radius: 10px;
  background: var(--accent);
  color: #fff;
  font-size: 11px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transform: scale(0.5);
  transition: all 0.2s;
}

.plate-btn .plate-count.visible {
  opacity: 1;
  transform: scale(1);
}

.plate-btn.has-plates {
  border-color: var(--accent);
  background: var(--accent-glow);
}

.plate-btn.at-limit {
  opacity: 0.35;
  cursor: default;
}

/* colored top border for competition plates */
.plate-btn[data-weight="25"]  { border-top: 3px solid var(--plate-red); }
.plate-btn[data-weight="20"]  { border-top: 3px solid var(--plate-blue); }
.plate-btn[data-weight="15"]  { border-top: 3px solid var(--plate-yellow); }
.plate-btn[data-weight="10"]  { border-top: 3px solid var(--plate-green); }
.plate-btn[data-weight="5"]   { border-top: 3px solid var(--plate-white); }

/* === ACTIONS === */
.actions {
  display: flex;
  gap: 8px;
  padding: 40px 12px 12px;
  padding-bottom: calc(12px + var(--safe-bottom));
  flex-shrink: 0;
}

.action-btn {
  flex: 1;
  padding: 14px;
  border: 2px solid var(--border);
  border-radius: 14px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  -webkit-tap-highlight-color: transparent;
}

.action-btn:active {
  transform: scale(0.96);
}

.action-btn.clear {
  border-color: #d42b2b33;
  color: #ff6b6b;
}

.action-btn.undo {
  border-color: var(--border);
}

/* === SETTINGS OVERLAY === */
.settings-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  z-index: 100;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s;
  -webkit-backdrop-filter: blur(4px);
  backdrop-filter: blur(4px);
}

.settings-overlay.open {
  opacity: 1;
  pointer-events: auto;
}

.settings-panel {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--surface);
  border-radius: 20px 20px 0 0;
  padding: 20px 16px;
  padding-bottom: calc(20px + var(--safe-bottom));
  max-height: 90vh;
  overflow-y: auto;
  transform: translateY(100%);
  transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  -webkit-overflow-scrolling: touch;
}

.settings-overlay.open .settings-panel {
  transform: translateY(0);
}

.settings-handle {
  width: 36px;
  height: 4px;
  border-radius: 2px;
  background: var(--border);
  margin: 0 auto 16px;
}

.settings-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 4px;
}

.settings-title {
  font-size: 18px;
  font-weight: 700;
}

.settings-close {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 50%;
  background: var(--surface2);
  color: var(--text-dim);
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}

.settings-desc {
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 16px;
  line-height: 1.4;
}

.settings-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 16px;
}

.setting-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 12px;
  border-radius: 12px;
  background: var(--bg);
}

.setting-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.setting-label {
  flex: 1;
  font-size: 15px;
  font-weight: 600;
}

.setting-controls {
  display: flex;
  align-items: center;
  gap: 4px;
}

.setting-adj {
  width: 34px;
  height: 34px;
  border: 1.5px solid var(--border);
  border-radius: 10px;
  background: var(--surface);
  color: var(--text);
  font-size: 18px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: all 0.1s;
}

.setting-adj:active {
  transform: scale(0.9);
  background: var(--surface2);
}

.setting-value {
  width: 36px;
  text-align: center;
  font-size: 16px;
  font-weight: 700;
  font-variant-numeric: tabular-nums;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}

.setting-value.unlimited {
  color: var(--text-dim);
}

.settings-reset {
  width: 100%;
  padding: 14px;
  margin-top: 8px;
  margin-bottom: 8px;
  border: 2px solid var(--accent);
  border-radius: 12px;
  background: var(--accent-glow);
  color: var(--text);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}

.settings-reset:active {
  transform: scale(0.98);
}

/* === ANIMATIONS === */
@keyframes bump {
  0% { transform: scale(1); }
  50% { transform: scale(1.08); }
  100% { transform: scale(1); }
}

.total-weight.bump {
  animation: bump 0.2s ease;
}
</style>
</head>
<body>

<!-- Total Weight -->
<div class="total-section">
  <button class="gear-btn" id="gearBtn" onclick="openSettings()" aria-label="Plate inventory setup">
    <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58a.49.49 0 00.12-.61l-1.92-3.32a.49.49 0 00-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.48.48 0 00-.48-.41h-3.84a.48.48 0 00-.48.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 00-.59.22L2.74 8.87a.48.48 0 00.12.61l2.03 1.58c-.05.3-.07.62-.07.94s.02.64.07.94l-2.03 1.58a.49.49 0 00-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.26.41.48.41h3.84c.24 0 .44-.17.48-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6A3.6 3.6 0 1115.6 12 3.61 3.61 0 0112 15.6z"/></svg>
  </button>
  <div>
    <span class="total-weight" id="totalWeight">20</span>
    <span class="total-unit">kg</span>
  </div>
  <div class="total-label">Total weight</div>
</div>

<!-- Bar Selector -->
<div class="bar-selector">
  <button class="bar-btn active" data-bar="20" onclick="setBar(20)">
    20 kg
    <span>Men's bar</span>
  </button>
  <button class="bar-btn" data-bar="15" onclick="setBar(15)">
    15 kg
    <span>Women's bar</span>
  </button>
</div>

<!-- Target Weight Calculator -->
<div class="target-section">
  <div class="target-row">
    <input type="number" id="targetInput" class="target-input" placeholder="Target weight (kg)" inputmode="decimal" min="0" step="0.5">
    <button class="target-btn" onclick="calculateTarget()">Load</button>
  </div>
  <div class="target-message" id="targetMessage"></div>
</div>

<!-- Barbell Visual -->
<div class="barbell-container">
  <svg id="barbellSvg" class="barbell-svg" viewBox="0 0 400 100" xmlns="http://www.w3.org/2000/svg"></svg>
</div>

<!-- Per-side Breakdown -->
<div class="breakdown">
  <div class="breakdown-title">Per side</div>
  <div class="breakdown-list" id="breakdownList">
    <div class="breakdown-empty">Bar only</div>
  </div>
</div>

<!-- Plate Buttons -->
<div class="plates-section">
  <div class="plates-grid" id="platesGrid"></div>
</div>

<!-- Actions -->
<div class="actions">
  <button class="action-btn undo" onclick="undoPlate()">Undo</button>
  <button class="action-btn clear" onclick="clearPlates()">Clear All</button>
</div>

<!-- Settings Overlay -->
<div class="settings-overlay" id="settingsOverlay" onclick="handleOverlayClick(event)">
  <div class="settings-panel" onclick="event.stopPropagation()">
    <div class="settings-handle"></div>
    <div class="settings-header">
      <span class="settings-title">Plate Inventory</span>
      <button class="settings-close" onclick="closeSettings()">&times;</button>
    </div>
    <div class="settings-desc">Set how many of each plate your gym has (total count across both sides). Tap a number to toggle unlimited.</div>
    <div class="settings-list" id="settingsList"></div>
    <button class="settings-reset" onclick="resetInventory()">Reset All to Unlimited</button>
  </div>
</div>

<script>
// ── State ──
const PLATES = [25, 20, 15, 10, 5, 2.5, 2, 1.25, 0.75, 0.5];
const PLATE_COLORS = {
  25:   { fill: '#d42b2b', stroke: '#a02020', label: '#fff' },
  20:   { fill: '#2b5fd4', stroke: '#1e44a0', label: '#fff' },
  15:   { fill: '#d4c12b', stroke: '#a09020', label: '#333' },
  10:   { fill: '#2bb84d', stroke: '#1e8838', label: '#fff' },
  5:    { fill: '#e8e8e8', stroke: '#b0b0b0', label: '#333' },
  2.5:  { fill: '#d42b2b', stroke: '#a02020', label: '#fff' },
  2:    { fill: '#2b5fd4', stroke: '#1e44a0', label: '#fff' },
  1.25: { fill: '#d4c12b', stroke: '#a09020', label: '#333' },
  0.75: { fill: '#2bb84d', stroke: '#1e8838', label: '#fff' },
  0.5:  { fill: '#e8e8e8', stroke: '#b0b0b0', label: '#333' },
};

const PLATE_HEIGHTS = {
  25: 80, 20: 74, 15: 68, 10: 56, 5: 46,
  2.5: 38, 2: 34, 1.25: 30, 0.75: 26, 0.5: 22
};

const PLATE_WIDTHS = {
  25: 12, 20: 12, 15: 10, 10: 10, 5: 8,
  2.5: 6, 2: 6, 1.25: 5, 0.75: 5, 0.5: 4
};

let barWeight = 20;
let addedPlates = [];
let plateCountsPerSide = {};
PLATES.forEach(p => plateCountsPerSide[p] = 0);

// Plate inventory: null = unlimited, number = total plates in gym
let plateInventory = {};
PLATES.forEach(p => plateInventory[p] = null);

const STORAGE_KEY = 'barbell-calc-inventory';

// ── UI Refs ──
const totalWeightEl = document.getElementById('totalWeight');
const breakdownListEl = document.getElementById('breakdownList');
const barbellSvg = document.getElementById('barbellSvg');
const platesGridEl = document.getElementById('platesGrid');
const targetInput = document.getElementById('targetInput');
const targetMessageEl = document.getElementById('targetMessage');
const settingsOverlay = document.getElementById('settingsOverlay');
const settingsList = document.getElementById('settingsList');
const gearBtn = document.getElementById('gearBtn');

// ── Format weight without rounding errors ──
function formatWeight(w) {
  const rounded = Math.round(w * 100) / 100;
  if (rounded % 1 === 0) return rounded.toString();
  return parseFloat(rounded.toFixed(2)).toString();
}

// ── Inventory persistence ──
function loadInventory() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      PLATES.forEach(p => {
        const key = String(p);
        if (key in parsed) plateInventory[p] = parsed[key];
      });
    }
  } catch (e) {}
}

function saveInventory() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(plateInventory));
  } catch (e) {}
}

function maxPerSide(weight) {
  const inv = plateInventory[weight];
  return inv === null ? Infinity : Math.floor(inv / 2);
}

function hasAnyLimits() {
  return PLATES.some(p => plateInventory[p] !== null);
}

// ── Initialize plate buttons ──
function buildPlateButtons() {
  platesGridEl.innerHTML = '';
  PLATES.forEach(weight => {
    const btn = document.createElement('button');
    btn.className = 'plate-btn';
    btn.dataset.weight = weight;
    btn.onclick = () => addPlate(weight);
    btn.innerHTML = `
      ${formatWeight(weight)}
      <span class="plate-label">kg</span>
      <span class="plate-count" id="count-${weight.toString().replace('.', '_')}">0</span>
    `;
    platesGridEl.appendChild(btn);
  });
}

// ── Bar selection ──
function setBar(weight) {
  barWeight = weight;
  document.querySelectorAll('.bar-btn').forEach(b => {
    b.classList.toggle('active', Number(b.dataset.bar) === weight);
  });
  clearTargetMessage();
  updateDisplay();
}

// ── Plate management ──
function addPlate(weight) {
  if (plateCountsPerSide[weight] >= maxPerSide(weight)) return;
  addedPlates.push(weight);
  plateCountsPerSide[weight]++;
  clearTargetMessage();
  updateDisplay();
}

function removePlate(weight) {
  if (plateCountsPerSide[weight] <= 0) return;
  for (let i = addedPlates.length - 1; i >= 0; i--) {
    if (addedPlates[i] === weight) {
      addedPlates.splice(i, 1);
      break;
    }
  }
  plateCountsPerSide[weight]--;
  clearTargetMessage();
  updateDisplay();
}

function undoPlate() {
  if (addedPlates.length === 0) return;
  const last = addedPlates.pop();
  plateCountsPerSide[last]--;
  clearTargetMessage();
  updateDisplay();
}

function clearPlates() {
  addedPlates = [];
  PLATES.forEach(p => plateCountsPerSide[p] = 0);
  clearTargetMessage();
  updateDisplay();
}

// ── Update everything ──
function updateDisplay() {
  const perSide = addedPlates.reduce((s, p) => s + p, 0);
  const total = barWeight + perSide * 2;
  totalWeightEl.textContent = formatWeight(total);
  totalWeightEl.classList.remove('bump');
  void totalWeightEl.offsetWidth;
  totalWeightEl.classList.add('bump');

  PLATES.forEach(weight => {
    const id = 'count-' + weight.toString().replace('.', '_');
    const countEl = document.getElementById(id);
    const count = plateCountsPerSide[weight];
    countEl.textContent = count * 2;
    countEl.classList.toggle('visible', count > 0);

    const btn = countEl.closest('.plate-btn');
    btn.classList.toggle('has-plates', count > 0);

    const atLimit = count >= maxPerSide(weight);
    btn.classList.toggle('at-limit', atLimit);
    btn.disabled = atLimit;
  });

  gearBtn.classList.toggle('has-limits', hasAnyLimits());

  updateBreakdown();
  drawBarbell();
}

// ── Per-side breakdown ──
function updateBreakdown() {
  const groups = [];
  PLATES.forEach(weight => {
    const count = plateCountsPerSide[weight];
    if (count > 0) groups.push({ weight, count });
  });

  if (groups.length === 0) {
    breakdownListEl.innerHTML = '<div class="breakdown-empty">Bar only</div>';
    return;
  }

  breakdownListEl.innerHTML = groups.map(g => {
    const color = PLATE_COLORS[g.weight].fill;
    return `<div class="breakdown-chip" onclick="removePlate(${g.weight})" title="Tap to remove one">
      <span class="dot" style="background:${color}"></span>
      ${formatWeight(g.weight)}kg
      <span class="count">&times;${g.count}</span>
    </div>`;
  }).join('');
}

// ── Target weight calculator ──
function clearTargetMessage() {
  targetMessageEl.textContent = '';
  targetMessageEl.className = 'target-message';
}

function showTargetMessage(text, type) {
  targetMessageEl.textContent = text;
  targetMessageEl.className = 'target-message ' + type;
}

// Bounded coin-change DP: respects per-side plate inventory limits.
// Converts weights to quarter-kg integers to avoid floating point.
function solvePlatesForTarget(targetPerSide) {
  if (targetPerSide < 0.001) return { plates: [], exact: true, actualPerSide: 0 };

  const PLATE_Q = PLATES.map(p => Math.round(p * 4));
  const targetQ = Math.round(targetPerSide * 4);
  const maxQ = targetQ + 8;

  const limits = PLATES.map((p, i) => {
    const m = maxPerSide(p);
    return m === Infinity ? Math.floor(maxQ / PLATE_Q[i]) + 1 : m;
  });

  // dp[w] = min plates to reach weight w; parent[w] for traceback
  const dp = new Array(maxQ + 1).fill(Infinity);
  const parent = new Array(maxQ + 1).fill(null);
  dp[0] = 0;

  for (let i = 0; i < PLATES.length; i++) {
    const pq = PLATE_Q[i];
    const limit = limits[i];
    if (limit === 0 || pq === 0) continue;

    // Snapshot before processing this plate type
    const prevDp = dp.slice();
    const prevParent = parent.slice();

    for (let w = 0; w <= maxQ; w++) {
      if (prevDp[w] === Infinity) continue;
      for (let k = 1; k <= limit; k++) {
        const nw = w + k * pq;
        if (nw > maxQ) break;
        const cost = prevDp[w] + k;
        if (cost < dp[nw]) {
          dp[nw] = cost;
          parent[nw] = { idx: i, count: k, prev: w };
        }
      }
    }
  }

  let bestQ = -1;
  for (let delta = 0; delta <= maxQ; delta++) {
    const under = targetQ - delta;
    const over = targetQ + delta;
    if (under >= 0 && dp[under] < Infinity) { bestQ = under; break; }
    if (over <= maxQ && dp[over] < Infinity) { bestQ = over; break; }
  }

  if (bestQ <= 0) return { plates: [], exact: targetQ === 0, actualPerSide: 0 };

  const plates = [];
  let w = bestQ;
  while (w > 0 && parent[w]) {
    for (let k = 0; k < parent[w].count; k++) plates.push(PLATES[parent[w].idx]);
    w = parent[w].prev;
  }

  return {
    plates: plates.sort((a, b) => b - a),
    exact: bestQ === targetQ,
    actualPerSide: bestQ / 4
  };
}

function calculateTarget() {
  const raw = targetInput.value.trim();
  if (!raw) return;

  const targetTotal = parseFloat(raw);
  if (isNaN(targetTotal) || targetTotal <= 0) {
    showTargetMessage('Enter a valid weight', 'error');
    return;
  }

  if (targetTotal < barWeight) {
    showTargetMessage(`Minimum is ${barWeight}kg (bar only)`, 'error');
    return;
  }

  if (targetTotal === barWeight) {
    clearPlates();
    showTargetMessage(`Exact: ${formatWeight(barWeight)}kg`, 'exact');
    return;
  }

  const targetPerSide = (targetTotal - barWeight) / 2;
  const result = solvePlatesForTarget(targetPerSide);

  addedPlates = [];
  PLATES.forEach(p => plateCountsPerSide[p] = 0);
  result.plates.forEach(p => {
    addedPlates.push(p);
    plateCountsPerSide[p]++;
  });
  updateDisplay();

  const actualTotal = barWeight + result.actualPerSide * 2;
  if (result.exact) {
    showTargetMessage(`Exact: ${formatWeight(actualTotal)}kg`, 'exact');
  } else {
    showTargetMessage(`Closest possible: ${formatWeight(actualTotal)}kg`, 'closest');
  }
}

targetInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    e.preventDefault();
    calculateTarget();
    targetInput.blur();
  }
});

// ── Settings panel ──
function openSettings() {
  renderSettings();
  settingsOverlay.classList.add('open');
}

function closeSettings() {
  settingsOverlay.classList.remove('open');
}

function handleOverlayClick(e) {
  if (e.target === settingsOverlay) closeSettings();
}

function renderSettings() {
  settingsList.innerHTML = PLATES.map(weight => {
    const color = PLATE_COLORS[weight].fill;
    const inv = plateInventory[weight];
    const isUnlimited = inv === null;
    const valueClass = isUnlimited ? 'setting-value unlimited' : 'setting-value';
    const display = isUnlimited ? '∞' : inv;
    return `<div class="setting-row">
      <span class="setting-dot" style="background:${color}"></span>
      <span class="setting-label">${formatWeight(weight)} kg</span>
      <div class="setting-controls">
        <button class="setting-adj" type="button" data-w="${weight}" data-d="-1">−</button>
        <span class="${valueClass}" data-w="${weight}" data-toggle="1">${display}</span>
        <button class="setting-adj" type="button" data-w="${weight}" data-d="1">+</button>
      </div>
    </div>`;
  }).join('');
}

// Event delegation for settings buttons — avoids inline onclick on rebuilt innerHTML
settingsList.addEventListener('click', e => {
  const adj = e.target.closest('.setting-adj');
  if (adj) {
    adjustInventory(parseFloat(adj.dataset.w), parseInt(adj.dataset.d));
    return;
  }
  const val = e.target.closest('[data-toggle]');
  if (val) {
    toggleUnlimited(parseFloat(val.dataset.w));
  }
});

function adjustInventory(weight, delta) {
  const current = plateInventory[weight];
  if (current === null) {
    // Either +/- from unlimited enters number mode at 0
    plateInventory[weight] = 0;
  } else {
    const newVal = current + delta;
    if (newVal < 0) {
      plateInventory[weight] = null; // back to unlimited
    } else {
      plateInventory[weight] = newVal;
    }
  }
  saveInventory();
  renderSettings();
  updateDisplay();
}

function toggleUnlimited(weight) {
  if (plateInventory[weight] === null) {
    plateInventory[weight] = 0;
  } else {
    plateInventory[weight] = null;
  }
  saveInventory();
  renderSettings();
  updateDisplay();
}

function resetInventory() {
  PLATES.forEach(p => plateInventory[p] = null);
  saveInventory();
  renderSettings();
  updateDisplay();
}

// ── Draw barbell SVG ──
function drawBarbell() {
  const sortedPlates = [];
  PLATES.forEach(weight => {
    for (let i = 0; i < plateCountsPerSide[weight]; i++) {
      sortedPlates.push(weight);
    }
  });

  const platesTotalWidth = sortedPlates.reduce((s, w) => s + PLATE_WIDTHS[w] + 2, 0);
  const sleeveLen = Math.max(platesTotalWidth + 20, 50);
  const collarW = 6;
  const shaftHalf = 60;
  const halfWidth = shaftHalf + collarW + sleeveLen + 10;
  const totalW = halfWidth * 2;
  const cy = 50;

  barbellSvg.setAttribute('viewBox', `0 0 ${totalW} 100`);
  const cx = totalW / 2;

  let svg = '';

  svg += `<defs>
    <linearGradient id="steelGrad" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#888"/>
      <stop offset="30%" stop-color="#ccc"/>
      <stop offset="50%" stop-color="#ddd"/>
      <stop offset="70%" stop-color="#bbb"/>
      <stop offset="100%" stop-color="#777"/>
    </linearGradient>
    <linearGradient id="sleeveGrad" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#999"/>
      <stop offset="25%" stop-color="#d0d0d0"/>
      <stop offset="50%" stop-color="#e0e0e0"/>
      <stop offset="75%" stop-color="#c0c0c0"/>
      <stop offset="100%" stop-color="#888"/>
    </linearGradient>
    <linearGradient id="knurlGrad" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#666"/>
      <stop offset="30%" stop-color="#aaa"/>
      <stop offset="50%" stop-color="#bbb"/>
      <stop offset="70%" stop-color="#999"/>
      <stop offset="100%" stop-color="#555"/>
    </linearGradient>
    <pattern id="knurlPattern" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse">
      <line x1="0" y1="0" x2="4" y2="4" stroke="#00000020" stroke-width="0.5"/>
      <line x1="4" y1="0" x2="0" y2="4" stroke="#00000020" stroke-width="0.5"/>
    </pattern>
  </defs>`;

  const barH = 8;
  const sleeveH = 14;

  svg += `<rect x="${cx - shaftHalf}" y="${cy - barH/2}" width="${shaftHalf * 2}" height="${barH}" rx="1" fill="url(#steelGrad)"/>`;

  const knurlZones = [
    [cx - shaftHalf + 6, cx - 14],
    [cx + 14, cx + shaftHalf - 6],
  ];
  knurlZones.forEach(([x1, x2]) => {
    svg += `<rect x="${x1}" y="${cy - barH/2}" width="${x2 - x1}" height="${barH}" rx="0" fill="url(#knurlGrad)"/>`;
    svg += `<rect x="${x1}" y="${cy - barH/2}" width="${x2 - x1}" height="${barH}" rx="0" fill="url(#knurlPattern)"/>`;
  });

  svg += `<rect x="${cx - 0.75}" y="${cy - barH/2 - 0.5}" width="1.5" height="${barH + 1}" fill="#666" rx="0.5"/>`;

  for (const side of [-1, 1]) {
    const dir = side;

    const collarX = cx + dir * shaftHalf;
    const collarDrawX = dir === 1 ? collarX : collarX - collarW;
    svg += `<rect x="${collarDrawX}" y="${cy - sleeveH/2 - 2}" width="${collarW}" height="${sleeveH + 4}" rx="1.5" fill="url(#steelGrad)" stroke="#666" stroke-width="0.5"/>`;

    const sleeveStart = cx + dir * (shaftHalf + collarW);
    const sleeveDrawX = dir === 1 ? sleeveStart : sleeveStart - sleeveLen;
    svg += `<rect x="${sleeveDrawX}" y="${cy - sleeveH/2}" width="${sleeveLen}" height="${sleeveH}" rx="1" fill="url(#sleeveGrad)" stroke="#999" stroke-width="0.3"/>`;

    const grooveStart = dir === 1 ? sleeveStart + 3 : sleeveStart - sleeveLen + 3;
    for (let i = 0; i < sleeveLen - 6; i += 3) {
      svg += `<line x1="${grooveStart + i}" y1="${cy - sleeveH/2}" x2="${grooveStart + i}" y2="${cy + sleeveH/2}" stroke="#b0b0b0" stroke-width="0.2" opacity="0.5"/>`;
    }

    const capX = cx + dir * (shaftHalf + collarW + sleeveLen);
    const capDrawX = dir === 1 ? capX : capX - 4;
    svg += `<rect x="${capDrawX}" y="${cy - sleeveH/2 - 1}" width="4" height="${sleeveH + 2}" rx="1.5" fill="#777" stroke="#666" stroke-width="0.5"/>`;

    let plateX = cx + dir * (shaftHalf + collarW + 4);
    sortedPlates.forEach(weight => {
      const ph = PLATE_HEIGHTS[weight];
      const pw = PLATE_WIDTHS[weight];
      const colors = PLATE_COLORS[weight];
      const drawX = dir === 1 ? plateX : plateX - pw;

      // Clickable plate group
      svg += `<g data-plate-weight="${weight}" style="cursor:pointer">`;

      svg += `<rect x="${drawX + 1}" y="${cy - ph/2 + 1}" width="${pw}" height="${ph}" rx="2" fill="rgba(0,0,0,0.3)"/>`;
      svg += `<rect x="${drawX}" y="${cy - ph/2}" width="${pw}" height="${ph}" rx="2" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="0.8"/>`;
      svg += `<rect x="${drawX + 1}" y="${cy - ph/2 + 1}" width="${pw - 2}" height="${ph/3}" rx="1" fill="rgba(255,255,255,0.15)"/>`;

      if (weight >= 10) {
        const hubCx = drawX + pw / 2;
        svg += `<circle cx="${hubCx}" cy="${cy}" r="6" fill="none" stroke="${colors.stroke}" stroke-width="0.6" opacity="0.5"/>`;
        svg += `<circle cx="${hubCx}" cy="${cy}" r="3" fill="${colors.stroke}" opacity="0.3"/>`;
      }

      if (pw >= 8) {
        const textX = drawX + pw / 2;
        const fontSize = weight >= 10 ? 6 : 5;
        svg += `<text x="${textX}" y="${cy + fontSize/3}" text-anchor="middle" font-size="${fontSize}" font-weight="700" fill="${colors.label}" opacity="0.8" font-family="system-ui">${formatWeight(weight)}</text>`;
      }

      // Invisible hit area for easier tapping
      svg += `<rect x="${drawX - 3}" y="${cy - ph/2 - 3}" width="${pw + 6}" height="${ph + 6}" fill="transparent"/>`;

      svg += `</g>`;

      plateX += dir * (pw + 2);
    });

    if (sortedPlates.length > 0) {
      const ccDrawX = dir === 1 ? plateX : plateX - 5;
      svg += `<rect x="${ccDrawX}" y="${cy - 10}" width="5" height="20" rx="1.5" fill="#555" stroke="#444" stroke-width="0.5"/>`;
      for (let r = 0; r < 3; r++) {
        svg += `<line x1="${ccDrawX}" y1="${cy - 7 + r * 7}" x2="${ccDrawX + 5}" y2="${cy - 7 + r * 7}" stroke="#666" stroke-width="0.5"/>`;
      }
    }
  }

  barbellSvg.innerHTML = svg;
}

// SVG plate click handler (event delegation)
barbellSvg.addEventListener('click', e => {
  const g = e.target.closest('[data-plate-weight]');
  if (g) {
    removePlate(parseFloat(g.dataset.plateWeight));
  }
});

// ── Init ──
loadInventory();
buildPlateButtons();
updateDisplay();

// ── Service Worker Registration ──
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
